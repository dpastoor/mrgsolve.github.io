# Topics {#topics}

## Set initial conditions {#topic-init}

``` {r}
library(mrgsolve)
library(dplyr)
```
```{r,echo=FALSE}
options(mrgsolve_mread_quiet = TRUE)
knitr::opts_chunk$set(comment='.')
```



### Summary


-   `mrgsolve` keeps a base list of compartments and initial conditions that you can update **either** from `R` or from inside the model specification
    -   When you use `$CMT`, the value in that base list is assumed to be 0 for every compartment
    -   `mrgsolve` will by default use the values in that base list when starting the problem
    -   When only the base list is available, every individual will get the same initial condition
-   You can **override** this base list by including code in `$MAIN` to set the initial condition
    -   Most often, you do this so that the initial is calculated as a function of a parameter
    -   For example, `$MAIN RESP_0 = KIN/KOUT;` when `KIN` and `KOUT` have some value in `$PARAM`
    -   This code in `$MAIN` overwrites the value in the base list for the current `ID`
-   For typical PK/PD type models, we most frequently initialize in `$MAIN`
    -   This is equivalent to what you might do in your NONMEM model
-   For larger systems models, we often just set the initial value via the base list

### Make a model only to examine `init` behavior


Note: `IFLAG` is my invention only for this demo. The demo is always responsible for setting and interpreting the value (it is not reserved in any way and `mrgsolve` does not control the value).

For this demo

-   Compartment `A` initial condition defaults to 0
-   Compartment `A` initial condition will get set to `BASE` **only** if `IFLAG  > 0`
-   Compartment `A` always stays at the initial condition

``` {r}
code <- '
$PARAM BASE=100, IFLAG = 0

$CMT A

$MAIN

if(IFLAG > 0) A_0 = BASE;

$ODE dxdt_A = 0;
'
```

``` {r}
mod <- mread("init",tempdir(),code)
```

**Check the initial condition**

``` {r}
init(mod)
```

Note:

-   We used `$CMT` in the model spec; that implies that the base initial condition for `A` is set to 0
-   In this chunk, the code in `$MAIN` doesn't get run because `IFLAG` is 0
-   So, if we don't update something in `$MAIN` the initial condition is as we set it in the base list

``` {r}
mod %>% mrgsim %>% plot
```


**Next, we update the base initial condition for `A` to 50**

Note:

-   The code in `$MAIN` still doesn't get run because `IFLAG` is 0

``` {r}
mod %>% init(A = 50) %>% mrgsim %>% plot
```

**Now, turn on `IFLAG`**

Note:

-   Now, that code in `$MAIN` gets run
-   `A_0` is set to the value of `BASE`

``` {r}
mod %>% param(IFLAG=1) %>% mrgsim %>% plot
```


``` {r}
mod %>% param(IFLAG=1, BASE=300) %>% mrgsim %>% plot
```


### Example PK/PD model with initial condition


Just to be clear, there is no need to set any sort of flag to set the initial condition.

``` {r}
code <- '
$PARAM AUC=0, AUC50 = 75, KIN=200, KOUT=5

$CMT RESP

$MAIN 
RESP_0 = KIN/KOUT;

$ODE

dxdt_RESP = KIN*(1-AUC/(AUC50+AUC)) - KOUT*RESP;

'
```

``` {r}
mod <- mread("init2", tempdir(), code)
```

The initial condition is set to 40 per the values of `KIN` and `KOUT`

``` {r}
mod %>% mrgsim %>% plot
```

Even when we change `RESP_0` in `R`, the calculation in `$MAIN` gets the final say

``` {r}
mod %>% init(RESP=1E9) %>% mrgsim
```


### Remember: calling `init` will let you check to see what is going on


-   It's a good idea to get in the habit of doing this when things aren't clear
-   `init` first takes the base initial condition list, then calls `$MAIN` and does any calculation you have in there; so the result is the calculated initials

``` {r}
init(mod)
```

``` {r}
mod %>% param(KIN=100) %>% init
```



### Set initial conditions via `idata`

Go back to house model

``` {r}
mod <- mrgsolve:::house()
```

``` {r}
init(mod)
```

Notes

-   In `idata` (only), include a column with `CMT_0` (like you'd do in `$MAIN`).
-   When each ID is simulated, the `idata` value will override the base initial list for that subject.
-   But note that if `CMT_0` is set in `$MAIN`, that will override the `idata` update.

``` {r}
idata <- expand.idata(CENT_0 = seq(0,25,1))
```

``` {r}
idata %>% head
```


``` {r}
out <- 
  mod %>% 
  idata_set(idata) %>% 
  mrgsim(end=40)
```

``` {r}
plot(out, CENT~.)
```


## Updating parameters {#topic-parameter-update}

__Base parameter set__

* Every model has a base set of "parameters"
* These are named and set in `$PARAM`
* Parameters can only get into the parameter list in `$PARAM` (or `$THETA`)
    * No changing the names or numbers of parameters once the model is compiled
    * But, several ways to change the values

```{r,message=FALSE}
code <- '
$VCMT KYLE
$PARAM CL = 1.1, VC=23.1, KA=1.7, KM=10
$CAPTURE CL VC KA KM
'
mod <- mread("tmp", tempdir(), code, warn=FALSE)
```

```{r}
param(mod)
```

__The base parameter set is the default__
The base parameter set allows you to run the model without entering any other data; there are some default values in place.  

The parameters can be changed or updated in `R`:
```{r}
mod %<>% param(CL=2.1)
```

```{r}
param(mod)
```
But whatever you've done in `R` there that base set (with values) are there to use. 


__Parameters can also be updated during the simulation run__

* Parameters can be updated via `idata` set or `data` set
* No changing values in the base parameter set once the simulation starts.

* `mrgsolve` always reverts to the base parameter set when starting work on a new individual.

__Parameters found in `idata`__

When `mrgsolve` finds parameters in `idata`, it will update the base parameter list with those parameters prior to starting that individual.

```{r}
data(exidata)
head(exidata)
```


```{r}
out <- mod %>%
  idata_set(exidata) %>%
  mrgsim(end=-1 , add=c(0,2))
```

```{r}
out
```

__Parameters found in `data`__
Like an `idata` set, we can put parameters on a `data` set

```{r}
data <- expand.ev(amt=0, CL=c(1,2,3), VC=30)
```

```{r}
out <- mod %>%
  data_set(data) %>% 
  obsonly %>%
  mrgsim(end=-1, add=c(0,2))
```
```{r}
out
```

This is how we do time-varying parameters:
```{r}
data <- data_frame(CL=seq(1,5)) %>%
  mutate(evid=0,ID=1,cmt=1,time=CL-1,amt=0)
```

```{r}
mod %>%
  data_set(data) %>%
  mrgsim(end=-1)
```



__Parameters are carried back when first record isn't at `time == 0`s__

What about this?

```{r}
data <- expand.ev(amt=100,time=24,CL=5,VC=32)
data
```

The first `data` record happens at `time==24`

```{r}
mod %>% 
  data_set(data) %>%
  mrgsim(end=-1, add=c(0,2))
```

Since the data set doesn't start until `time==5`, we might think that `CL` doesn't change from the base parameter set until then.  

But by default, `mrgsolve` carries those parameter values back to the start of the simulation.  This is by design ... by far the more useful configuration.

If you wanted the base parameter set in play until that first data set record, do this:

```{r}
mod %>%
  data_set(data) %>%
  mrgsim(end=-1,add=c(0,2), filbak=FALSE)
```

Will this work? 

```{r}

idata <- do.call("expand.idata", as.list(param(mod)))

idata

mod %>%
  data_set(data) %>%
  idata_set(idata) %>%
  mrgsim(end=-1,add=c(0,2))
```

The data set always gets the last word.



## Time grid objects {#topic-tgrid}

__Simulation times in `mrgsolve`__

```{r}
mod <- mrgsolve:::house() %>% Req(CP) %>% ev(amt=1000,ii=24, addl=1000) 
```


`mrgsolve` keeps track of a simulation `start` and `end` time and a 
fixed size step between `start` and `end` (called `delta`).  `mrgsolve`
also keeps an arbitrary vector of simulation times called `add`. 

```{r}
mod %>%
  mrgsim(end=4,delta=2,add=c(7,9,50)) %>%
  as.data.frame
```


__`tgrid` objects__
 
The `tgrid` object abstracts this setup and allows us to make 
complicated sampling designs from elementary building blocks.

__Make a day 1 sampling with intensive sampling around the peak and sparser otherwise__
```{r}
peak1 <- tgrid(1,4,0.1)
sparse1 <- tgrid(0,24,4)
```
 
__Use the `c` operator to combine simpler designs into more complicated designs__
```{r}
day1 <- c(peak1,sparse1)
```

Check this by calling `stime`
```{r}
stime(day1)
```

Pass this object in to `mrgsim` as `tgrid`.  It will override the default `start/end/delta/add` sequence.
```{r}
mod %>% 
  mrgsim(tgrid=day1) %>%
  plot(type='b')
```

 
__Now, look at both day 1 and day 10__:
 
Adding a number to a `tgrid` object will offset those times by that amount.  

```{r}
des <- c(day1, day1+10*24)

mod %>% 
  mrgsim(tgrid=des) %>%
  plot(type='b')


```

Pick up day 5 as well

```{r}
des <- c(des, day1+5*24)

mod %>% 
  mrgsim(tgrid=des) %>%
  plot(type='b')
```



## Individualized sampling designs {#topic-designs}

```{r}

mod <- mrgsolve:::house()


df <- expand.ev(ID=1:3, amt=c(50,100))

df

data(exTheoph)
df <- exTheoph
head(df)

out <- 
mod %>% 
  Req(CP) %>%
  carry.out(a.u.g) %>%
  data_set(df) %>%
  obsaug %>%
  mrgsim 


des1 <- tgrid(0,24,1, add=0.2)
des2 <- tgrid(0,96,1)

df %<>% mutate(GRP = as.integer(ID > 5))
id <- df %>% distinct(ID) %>% select(ID,GRP)


out <- 
  mod %>% 
  Req(CP) %>%
  carry.out(a.u.g,GRP) %>%
  idata_set(id) %>%
  data_set(df) %>%
  design(descol="GRP", deslist=list(des1,des2)) %>%
  obsaug %>%
  mrgsim 

plot(out, CP~time|GRP)
```

## Some helpful `C++`

```{c,eval=FALSE}

// If
if(a == 2) b = 2;

// If else
if(b <= 2) {
  c=3;
} else {
  c=4;
}

// x <- ifelse(c == 4, 8, 10)
double x = c == 4 ? 8 : 10;

double d = pow(base,exponent);
double e = exp(3);
double f = fabs(-4);
double g = sqrt(5);
double h = log(6);
double i = log10(7);
double j = floor(4.2);
double k = ceil(4.2);
```

## How to update `$OMEGA` and `$SIGMA` matrices


