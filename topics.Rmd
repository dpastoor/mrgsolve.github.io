# Topics {#topics}

## Set initial conditions {#topic-init}

``` {r}
library(mrgsolve)
library(dplyr)
```
```{r,echo=FALSE}
options(mrgsolve_mread_quiet = TRUE)
knitr::opts_chunk$set(comment='.')
```



### Summary


-   `mrgsolve` keeps a base list of compartments and initial conditions that you can update **either** from `R` or from inside the model specification
    -   When you use `$CMT`, the value in that base list is assumed to be 0 for every compartment
    -   `mrgsolve` will by default use the values in that base list when starting the problem
    -   When only the base list is available, every individual will get the same initial condition
-   You can **override** this base list by including code in `$MAIN` to set the initial condition
    -   Most often, you do this so that the initial is calculated as a function of a parameter
    -   For example, `$MAIN RESP_0 = KIN/KOUT;` when `KIN` and `KOUT` have some value in `$PARAM`
    -   This code in `$MAIN` overwrites the value in the base list for the current `ID`
-   For typical PK/PD type models, we most frequently initialize in `$MAIN`
    -   This is equivalent to what you might do in your NONMEM model
-   For larger systems models, we often just set the initial value via the base list

### Make a model only to examine `init` behavior


Note: `IFLAG` is my invention only for this demo. The demo is always responsible for setting and interpreting the value (it is not reserved in any way and `mrgsolve` does not control the value).

For this demo

-   Compartment `A` initial condition defaults to 0
-   Compartment `A` initial condition will get set to `BASE` **only** if `IFLAG  > 0`
-   Compartment `A` always stays at the initial condition

``` {r}
code <- '
$PARAM BASE=100, IFLAG = 0

$CMT A

$MAIN

if(IFLAG > 0) A_0 = BASE;

$ODE dxdt_A = 0;
'
```

``` {r}
mod <- mread("init",tempdir(),code)
```

**Check the initial condition**

``` {r}
init(mod)
```

Note:

-   We used `$CMT` in the model spec; that implies that the base initial condition for `A` is set to 0
-   In this chunk, the code in `$MAIN` doesn't get run because `IFLAG` is 0
-   So, if we don't update something in `$MAIN` the initial condition is as we set it in the base list

``` {r}
mod %>% mrgsim %>% plot
```


**Next, we update the base initial condition for `A` to 50**

Note:

-   The code in `$MAIN` still doesn't get run because `IFLAG` is 0

``` {r}
mod %>% init(A = 50) %>% mrgsim %>% plot
```

**Now, turn on `IFLAG`**

Note:

-   Now, that code in `$MAIN` gets run
-   `A_0` is set to the value of `BASE`

``` {r}
mod %>% param(IFLAG=1) %>% mrgsim %>% plot
```


``` {r}
mod %>% param(IFLAG=1, BASE=300) %>% mrgsim %>% plot
```


### Example PK/PD model with initial condition


Just to be clear, there is no need to set any sort of flag to set the initial condition.

``` {r}
code <- '
$PARAM AUC=0, AUC50 = 75, KIN=200, KOUT=5

$CMT RESP

$MAIN 
RESP_0 = KIN/KOUT;

$ODE

dxdt_RESP = KIN*(1-AUC/(AUC50+AUC)) - KOUT*RESP;

'
```

``` {r}
mod <- mread("init2", tempdir(), code)
```

The initial condition is set to 40 per the values of `KIN` and `KOUT`

``` {r}
mod %>% mrgsim %>% plot
```

Even when we change `RESP_0` in `R`, the calculation in `$MAIN` gets the final say

``` {r}
mod %>% init(RESP=1E9) %>% mrgsim
```


### Remember: calling `init` will let you check to see what is going on


-   It's a good idea to get in the habit of doing this when things aren't clear
-   `init` first takes the base initial condition list, then calls `$MAIN` and does any calculation you have in there; so the result is the calculated initials

``` {r}
init(mod)
```

``` {r}
mod %>% param(KIN=100) %>% init
```



### Set initial conditions via `idata`

Go back to house model

``` {r}
mod <- mrgsolve:::house()
```

``` {r}
init(mod)
```

Notes

-   In `idata` (only), include a column with `CMT_0` (like you'd do in `$MAIN`).
-   When each ID is simulated, the `idata` value will override the base initial list for that subject.
-   But note that if `CMT_0` is set in `$MAIN`, that will override the `idata` update.

``` {r}
idata <- expand.idata(CENT_0 = seq(0,25,1))
```

``` {r}
idata %>% head
```


``` {r}
out <- 
  mod %>% 
  idata_set(idata) %>% 
  mrgsim(end=40)
```

``` {r}
plot(out, CENT~.)
```


## Updating parameters {#topic-parameter-update}


## Time grid objects {#topic-tgrid}

### Simulation times in `mrgsolve`

```{r}
mod <- mrgsolve:::house() %>% Req(CP) %>% ev(amt=1000,ii=24, addl=1000) 
```


`mrgsolve` keeps track of a simulation `start` and `end` time and a 
fixed size step between `start` and `end` (called `delta`).  `mrgsolve`
also keeps an arbitrary vector of simulation times called `add`. 

```{r}
mod %>%
  mrgsim(end=4,delta=2,add=c(7,9,50)) %>%
  as.data.frame
```


### `tgrid` objects
 
The `tgrid` object abstracts this setup and allows us to make 
complicated sampling designs from elementary building blocks.

__Make a day 1 sampling with intensive sampling around the peak and sparser otherwise__
```{r}
peak1 <- tgrid(1,4,0.1)
sparse1 <- tgrid(0,24,4)
```
 
__Use the `c` operator to combine simpler designs into more complicated designs__
```{r}
day1 <- c(peak1,sparse1)
```

Check this by calling `stime`
```{r}
stime(day1)
```

Pass this object in to `mrgsim` as `tgrid`.  It will override the default `start/end/delta/add` sequence.
```{r}
mod %>% 
  mrgsim(tgrid=day1) %>%
  plot(type='b')
```

 
__Now, look at both day 1 and day 10__:
 
Adding a number to a `tgrid` object will offset those times by that amount.  

```{r}
des <- c(day1, day1+10*24)

mod %>% 
  mrgsim(tgrid=des) %>%
  plot(type='b')


```

Pick up day 5 as well

```{r}
des <- c(des, day1+5*24)

mod %>% 
  mrgsim(tgrid=des) %>%
  plot(type='b')
```



## Individualized sampling designs {#topic-designs}

```{r}

mod <- mrgsolve:::house()


df <- expand.ev(ID=1:3, amt=c(50,100))

df

data(exTheoph)
df <- exTheoph
head(df)

out <- 
mod %>% 
  Req(CP) %>%
  carry.out(a.u.g) %>%
  data_set(df) %>%
  obsaug %>%
  mrgsim 


des1 <- tgrid(0,24,1, add=0.2)
des2 <- tgrid(0,96,1)

df %<>% mutate(GRP = as.integer(ID > 5))
id <- df %>% distinct(ID) %>% select(ID,GRP)


out <- 
  mod %>% 
  Req(CP) %>%
  carry.out(a.u.g,GRP) %>%
  idata_set(id) %>%
  data_set(df) %>%
  design(descol="GRP", deslist=list(des1,des2)) %>%
  obsaug %>%
  mrgsim 

plot(out, CP~time|GRP)
```