# Topics {#topics}

## Set initial conditions {#topic-init}

``` {r}
library(mrgsolve)
library(dplyr)
```
```{r,echo=FALSE}
options(mrgsolve_mread_quiet = TRUE)
knitr::opts_chunk$set(comment='.')
```



### Summary


-   `mrgsolve` keeps a base list of compartments and initial conditions that you can update **either** from `R` or from inside the model specification
    -   When you use `$CMT`, the value in that base list is assumed to be 0 for every compartment
    -   `mrgsolve` will by default use the values in that base list when starting the problem
    -   When only the base list is available, every individual will get the same initial condition
-   You can **override** this base list by including code in `$MAIN` to set the initial condition
    -   Most often, you do this so that the initial is calculated as a function of a parameter
    -   For example, `$MAIN RESP_0 = KIN/KOUT;` when `KIN` and `KOUT` have some value in `$PARAM`
    -   This code in `$MAIN` overwrites the value in the base list for the current `ID`
-   For typical PK/PD type models, we most frequently initialize in `$MAIN`
    -   This is equivalent to what you might do in your NONMEM model
-   For larger systems models, we often just set the initial value via the base list

### Make a model only to examine `init` behavior


Note: `IFLAG` is my invention only for this demo. The demo is always responsible for setting and interpreting the value (it is not reserved in any way and `mrgsolve` does not control the value).

For this demo

-   Compartment `A` initial condition defaults to 0
-   Compartment `A` initial condition will get set to `BASE` **only** if `IFLAG  > 0`
-   Compartment `A` always stays at the initial condition

``` {r}
code <- '
$PARAM BASE=100, IFLAG = 0

$CMT A

$MAIN

if(IFLAG > 0) A_0 = BASE;

$ODE dxdt_A = 0;
'
```

``` {r}
mod <- mread("init",tempdir(),code)
```

**Check the initial condition**

``` {r}
init(mod)
```

Note:

-   We used `$CMT` in the model spec; that implies that the base initial condition for `A` is set to 0
-   In this chunk, the code in `$MAIN` doesn't get run because `IFLAG` is 0
-   So, if we don't update something in `$MAIN` the initial condition is as we set it in the base list

``` {r}
mod %>% mrgsim %>% plot
```


**Next, we update the base initial condition for `A` to 50**

Note:

-   The code in `$MAIN` still doesn't get run because `IFLAG` is 0

``` {r}
mod %>% init(A = 50) %>% mrgsim %>% plot
```

**Now, turn on `IFLAG`**

Note:

-   Now, that code in `$MAIN` gets run
-   `A_0` is set to the value of `BASE`

``` {r}
mod %>% param(IFLAG=1) %>% mrgsim %>% plot
```


``` {r}
mod %>% param(IFLAG=1, BASE=300) %>% mrgsim %>% plot
```


### Example PK/PD model with initial condition


Just to be clear, there is no need to set any sort of flag to set the initial condition.

``` {r}
code <- '
$PARAM AUC=0, AUC50 = 75, KIN=200, KOUT=5

$CMT RESP

$MAIN 
RESP_0 = KIN/KOUT;

$ODE

dxdt_RESP = KIN*(1-AUC/(AUC50+AUC)) - KOUT*RESP;

'
```

``` {r}
mod <- mread("init2", tempdir(), code)
```

The initial condition is set to 40 per the values of `KIN` and `KOUT`

``` {r}
mod %>% mrgsim %>% plot
```

Even when we change `RESP_0` in `R`, the calculation in `$MAIN` gets the final say

``` {r}
mod %>% init(RESP=1E9) %>% mrgsim
```


### Remember: calling `init` will let you check to see what is going on


-   It's a good idea to get in the habit of doing this when things aren't clear
-   `init` first takes the base initial condition list, then calls `$MAIN` and does any calculation you have in there; so the result is the calculated initials

``` {r}
init(mod)
```

``` {r}
mod %>% param(KIN=100) %>% init
```



### Set initial conditions via `idata`

Go back to house model

``` {r}
mod <- mrgsolve:::house()
```

``` {r}
init(mod)
```

Notes

-   In `idata` (only), include a column with `CMT_0` (like you'd do in `$MAIN`).
-   When each ID is simulated, the `idata` value will override the base initial list for that subject.
-   But note that if `CMT_0` is set in `$MAIN`, that will override the `idata` update.

``` {r}
idata <- expand.idata(CENT_0 = seq(0,25,1))
```

``` {r}
idata %>% head
```


``` {r}
out <- 
  mod %>% 
  idata_set(idata) %>% 
  mrgsim(end=40)
```

``` {r}
plot(out, CENT~.)
```


## Updating parameters {#topic-parameter-update}

The parameter list was introduced in section \@ref(component-param) and the `$PARAM` code block was shown in \@ref(block-param).

### Parameter update hierarchy

__Base parameter set__

* Every model has a base set of "parameters"
* These are named and set in `$PARAM`
* Parameters can only get into the parameter list in `$PARAM` (or `$THETA`)
    * No changing the names or numbers of parameters once the model is compiled
    * But, several ways to change the values

```{r,message=FALSE}
code <- '
$VCMT KYLE
$PARAM CL = 1.1, VC=23.1, KA=1.7, KM=10
$CAPTURE CL VC KA KM
'
mod <- mcode("tmp", code, warn=FALSE)
```

```{r}
param(mod)
```

__The base parameter set is the default__

The base parameter set allows you to run the model without entering any other data; there are some default values in place.  

__The parameters in the base list can be changed or updated in `R`__

Use the `param()` function to both set and get:

```{r}
mod %<>% param(CL=2.1)
```

```{r}
param(mod)
```
But whatever you've done in `R`, there is a base set (with values) to use. 


__Parameters can also be updated during the simulation run__

Parameters can be updated by putting columns in `idata` set or `data_set` that have the same name as one of the parameters in the parameter list.  But there is no changing values in the base parameter set once the simulation starts.  That is, the following model specification will not compile:

```{c,eval=FALSE}
$PARAM CL = 2

$MAIN CL = 3; // ERROR
```

You cannot over-write the value of a parameter in the model specification.  Let `mrgsolve` do the updating.

`mrgsolve` always reverts to the base parameter set when starting work on a new individual.

__Parameters updated from `idata_set`__

When `mrgsolve` finds parameters in `idata`, it will update the base parameter list with those parameters prior to starting that individual.

```{r}
data(exidata)
head(exidata)
```

Notice that there are several columns in `exidata` that match up with the names in the parameter list
```{r}
names(exidata)

names(param(mod))
```

The matching names tell `mrgsolve` to update, assigning each individual their individual parameter.


```{r}
out <- 
  mod %>%
  idata_set(exidata) %>%
  mrgsim(end=-1 , add=c(0,2))
```

```{r}
out
```

__Parameters updated from `data_set`__

Like an `idata` set, we can put parameters on a `data` set

```{r}
data <- expand.ev(amt=0, CL=c(1,2,3), VC=30)
```

```{r}
out <- 
  mod %>%
  data_set(data) %>% 
  obsonly %>%
  mrgsim(end=-1, add=c(0,2))
```
```{r}
out
```

This is how we do time-varying parameters:
```{r}
data <- 
  data_frame(CL=seq(1,5)) %>%
  mutate(evid=0,ID=1,cmt=1,time=CL-1,amt=0)
```

```{r}
mod %>%
  data_set(data) %>%
  mrgsim(end=-1)
```



__Parameters are carried back when first record isn't at `time == 0`__

What about this?

```{r}
data <- expand.ev(amt=100,time=24,CL=5,VC=32)
data
```

The first `data` record happens at `time==24`

```{r}
mod %>% 
  data_set(data) %>%
  mrgsim(end=-1, add=c(0,2))
```

Since the data set doesn't start until `time==5`, we might think that `CL` doesn't change from the base parameter set until then.  

But by default, `mrgsolve` carries those parameter values back to the start of the simulation.  This is by design ... by far the more useful configuration.

If you wanted the base parameter set in play until that first data set record, do this:

```{r}
mod %>%
  data_set(data) %>%
  mrgsim(end=-1,add=c(0,2), filbak=FALSE)
```

Will this work? 

```{r}

idata <- do.call("expand.idata", as.list(param(mod)))

idata

```
Here, we'll pass in __both__ `data_set` and `idata_set` and they have conflicting values for the parameters.

```{r}

mod %>%
  data_set(data) %>%
  idata_set(idata) %>%
  mrgsim(end=-1,add=c(0,2))
```

The data set always gets the last word.


### Updating the base parameter list

From the previous section
```{r}
param(mod)
```

__Update with `name-value` pairs__

We can call `param()` to update the model object, directly naming the parameter to update and the new value to take

```{r}
mod %>% param(CL = 777, KM = 999) %>% param
```

The parameter list can also be updated by scanning the names in a list

```{r}
what <- list(CL = 555, VC = 888, KYLE = 123, MN = 100)

mod %>% param(what) %>% param
```

`mrgsolve` looks at the names to drive the update.  `KYLE` (a compartment name) and `MN` (not in the model anywhere) are ignored.

Alternatively, we can pick a row from a data frame to provide the input for the update
```{r}
d <- data_frame(CL=c(9,10), VC=c(11,12), KTB=c(13,14))

mod %>% param(d[2,]) %>% param

```

Here the second row in the data frame drives the update.  Other names are ignored.  

A warning will be issued if an update is attempted, but no matching names are found
```{r,eval=FALSE}
mod %>% param(ZIP = 1, CODE = 2) %>% param
```

```
Warning message:
Found nothing to update: param 
```



## Time grid objects {#topic-tgrid}

__Simulation times in `mrgsolve`__

```{r}
mod <- mrgsolve:::house() %>% Req(CP) %>% ev(amt=1000,ii=24, addl=1000) 
```


`mrgsolve` keeps track of a simulation `start` and `end` time and a 
fixed size step between `start` and `end` (called `delta`).  `mrgsolve`
also keeps an arbitrary vector of simulation times called `add`. 

```{r}
mod %>%
  mrgsim(end=4,delta=2,add=c(7,9,50)) %>%
  as.data.frame
```


__`tgrid` objects__
 
The `tgrid` object abstracts this setup and allows us to make 
complicated sampling designs from elementary building blocks.

__Make a day 1 sampling with intensive sampling around the peak and sparser otherwise__
```{r}
peak1 <- tgrid(1,4,0.1)
sparse1 <- tgrid(0,24,4)
```
 
__Use the `c` operator to combine simpler designs into more complicated designs__
```{r}
day1 <- c(peak1,sparse1)
```

Check this by calling `stime`
```{r}
stime(day1)
```

Pass this object in to `mrgsim` as `tgrid`.  It will override the default `start/end/delta/add` sequence.
```{r}
mod %>% 
  mrgsim(tgrid=day1) %>%
  plot(type='b')
```

 
__Now, look at both day 1 and day 10__:
 
Adding a number to a `tgrid` object will offset those times by that amount.  

```{r}
des <- c(day1, day1+10*24)

mod %>% 
  mrgsim(tgrid=des) %>%
  plot(type='b')


```

Pick up day 5 as well

```{r}
des <- c(des, day1+5*24)

mod %>% 
  mrgsim(tgrid=des) %>%
  plot(type='b')
```



## Individualized sampling designs {#topic-designs}

Here is a PopPK model and a full `data_set`.

```{r}
mod <- mrgsolve:::house()

data(exTheoph)

df <- exTheoph

head(df)
```

```{r}
mod %>% 
  Req(CP) %>%
  carry.out(a.u.g) %>%
  data_set(df) %>%
  obsaug %>%
  mrgsim 
```

Now, define two time grid objects: `des1` runs from 0 to 24 and `des2` runs from 0 to 96, both every hour.
```{r}

des1 <- tgrid(0,24,1)
des2 <- tgrid(0,96,1)

range(stime(des1))
range(stime(des2))
```

Now, derive an `idata_set` after adding a grouping column (`GRP`) that splits the data set into two groups
```{r}
df %<>% mutate(GRP = as.integer(ID > 5))

id <- df %>% distinct(ID) %>% select(ID,GRP)

id
```

Now, we have two groups in `GRP` in `idata_set` and we have two `tgrid` objects.  

* Pass in both the `idata_set` and the `data_set`
* Call `design`
    * Identify `GRP` as `descol`; the column __must__ be in `idata_set`
    * Pass in a list of designs; it __must__ be at least two because there are two levels in `GRP`
    
    
When we simulate, the individuals in `GRP 1` will get `des1` and those in `GRP 2` will get `des2`

```{r}
out <- 
  mod %>% 
  Req(CP) %>%
  carry.out(a.u.g,GRP) %>%
  idata_set(id) %>%
  data_set(df) %>%
  design(descol="GRP", deslist=list(des1,des2)) %>%
  obsaug %>%
  mrgsim 

plot(out, CP~time|GRP)
```


## Some helpful `C++`

```{c,eval=FALSE}

// If
if(a == 2) b = 2;

// If else
if(b <= 2) {
  c=3;
} else {
  c=4;
}

// x <- ifelse(c == 4, 8, 10)
double x = c == 4 ? 8 : 10;

double d = pow(base,exponent);
double e = exp(3);
double f = fabs(-4);
double g = sqrt(5);
double h = log(6);
double i = log10(7);
double j = floor(4.2);
double k = ceil(4.2);
```

## How to update `$OMEGA` and `$SIGMA` matrices {#topic-matrix-update}

Coming soon.
